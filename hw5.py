# -*- coding: utf-8 -*-
"""hw5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RRR5kf4ZNhoprfVmYgI53iaqgBnmolbt
"""

"""
CS161 | hw5.py
"""

##### Feel free to modify the classes/functions as you need #####

def best_score(V, i, j):
    """
    Given the values of n log segments, return the highest score that Brutus
    can obtain, given that he and Caesar are both playing optimally.
     - Note: Your algorithm should run in O(n^2).
     - You can assume that Brutus will always go first. Furthermore, you can
     assume that n is an even number, which entails that Caesar will always go
     last.

     Parameters
     ------------
     n : int
        The number of log segments. You can assume that n will be an even,
        non-zero, positive integer.
     V : list[int]
        The values of the log segments, in order (i.e. V[0] is the value of the
        log segment to the left of the log segment with value V[1], which is
        the value of the log segment to the left of the log segment with value
        V[2], etc.). You can assume that V will be non-empty and that each of
        its elements will be a non-zero, positive integer in the range of
        1 to 10^6.

     Returns
     ----------
     int : The highest score that Brutus can obtain, subject to the above
     conditions.
    """
    global memo

    if (len(V)==2):
      return max(V[0], V[1])

    if(memo[i][j]!=0):
      return memo[i][j]

    #min ceasar's best possible games after brutus picks from left and right
    brutus_left = V[0] + min(best_score(V[2:], i+2, j),best_score(V[1:-1], i+1, j-1))
    brutus_right = V[-1] + min(best_score(V[1:-1], i+1, j-1), best_score(V[:-2], i, j-2))

    highest_score = max(brutus_left, brutus_right)
    memo[i][j] = highest_score
    
    return highest_score


n = int(input())
#W =[5,10,30,10,5,30]
memo = [ [0]*n for i in range(n)]
V = list(map(int, input().split()))
print(best_score(V,0, len(V)-1), end="")